<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Submit a Doodle!!!</title>
    <style>
        body {
            background-color: #feb1cb;
            font-family: sans-serif;
            text-align: center;
            padding: 2rem;
        }

        canvas {
            border: 1px solid black;
            background: white;
            width: 400px;
            height: 300px;
            touch-action: none;
            margin: 0 auto;
        }

        #tools {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
        }

        .tool-icons {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .button {
            margin: 5px;
            padding: 10px;
            cursor: pointer;
        }

        #eraser, #brush, #eyedropper, #bucket {
            width: 32px;
            height: 32px;
            vertical-align: middle;
            cursor: pointer;
        }

        @media (max-width: 600px) {
            body {
                padding: 1rem;
            }

            #tools {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }

            .button, #brushSize, #colorPicker {
                width: 100%;
                max-width: 300px;
            }

            label {
                display: block;
                margin-top: 0.5rem;
            }

            #brushSize {
                margin: 0.25rem 0;
            }

            .tool-icons {
                gap: 1rem;
            }

            img {
                margin: 0 5px;
            }
        }
        #layerMenu {
            position: absolute;
            top: 55px;
            left: 20px;
            width: 200px;
            background: #fff;
            border: 1px solid #aaa;
            border-radius: 8px;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
            padding: 10px;
            display: none; /* Hidden by default */
            z-index: 1000;
            text-align: left;
        }

        #toggleLayerMenu {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1100;
            background: #ff89a4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-weight: bold;
        }

        #layerContent {
            margin-top: 10px; /* Increase this value for more space */
        }

        .layer-item.selected {
            border: 2px solid #ff4d88;
            border-radius: 6px;
            padding: 4px;
            background: #ffe5ed;
        }

        .layer-item {
            cursor: pointer;
            transition: background 0.2s ease;
        }

            .layer-item:hover {
                background: #fce4ec;
            }
        .layer-label {
            display: block;
            width: 100%;
            box-sizing: border-box;
            padding: 2px 4px;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease;
            background-color: transparent;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


            .layer-label:hover {
                background-color: #ff9cb1; /* Pink only around text */
            }




    </style>
</head>
<body>
    <h1>Submit a Doodle!!!</h1>
    <button id="toggleLayerMenu">â˜° Layers</button>
    <div id="layerMenu">
        <button id="addLayer" style="margin-bottom: 10px;">âž•</button>
        <div id="layerContent">
            <p>Background Layer</p>
        </div>
    </div>


    <canvas id="canvas" width="400" height="300"></canvas><br />

    <div id="tools">
        <button class="button" id="undo">Undo</button>
        <button class="button" id="redo">Redo</button>

        <label for="brushSize">Brush Size:</label>
        <input type="range" id="brushSize" min="1" max="10" value="2" />
        <span id="sizeLabel">2</span><br />

        <label for="colorPicker">Brush Color:</label>
        <input type="color" id="colorPicker" value="#000000" />

        <div class="tool-icons">
            <img id="brush" src="brush.png" alt="Brush Tool" title="Brush Tool" />
            <img id="eraser" src="eraser.png" alt="Eraser Tool" title="Eraser Tool" />
            <img id="eyedropper" src="eyedropper.png" alt="Eyedropper Tool" title="Eyedropper Tool" />
            <img id="bucket" src="bucket.png" alt="Bucket Tool" title="Bucket Tool" />
        </div>
    </div>

    <button id="submit">Submit</button>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const undoButton = document.getElementById("undo");
        const redoButton = document.getElementById("redo");
        const brushSizeInput = document.getElementById("brushSize");
        const sizeLabel = document.getElementById("sizeLabel");
        const colorPicker = document.getElementById("colorPicker");
        const eraserIcon = document.getElementById("eraser");
        const brushIcon = document.getElementById("brush");
        const eyedropperIcon = document.getElementById("eyedropper");
        const bucketIcon = document.getElementById("bucket");
        const submitButton = document.getElementById("submit");
        const toggleLayerMenu = document.getElementById("toggleLayerMenu");
        const layerMenu = document.getElementById("layerMenu");

        // Initialize layers array with a background layer
        let activeLayerIndex = 0;

        let layers = [
            {
                name: 'Background',
                canvas: document.createElement('canvas'),
                ctx: null,
                visible: true,
                undoStack: [],
                redoStack: []
            }
        ];




        // Set canvas dimensions for the background layer
        layers[0].canvas.width = canvas.width;
        layers[0].canvas.height = canvas.height;
        layers[0].ctx = layers[0].canvas.getContext('2d');
        setActiveLayer(0);        // Use the background as the active layer
        updateLayerMenu();        // Show the background layer in the UI


        document.getElementById("addLayer").addEventListener("click", addNewDrawingLayer);

        // Function to toggle visibility of layers
        function toggleLayerVisibility(index) {
            layers[index].visible = !layers[index].visible;
            renderAllLayers();
            updateLayerMenu(); 
        }


        function setActiveLayer(index) {
            activeLayerIndex = index;
            renderAllLayers();
            updateLayerMenu(); 
        }

        function addNewDrawingLayer() {
            const newLayer = {
                name: `Layer ${layers.length - 1}`,  // because layer[0] is background
                canvas: document.createElement('canvas'),
                ctx: null,
                visible: true,
                undoStack: [],
                redoStack: []
            };

            newLayer.canvas.width = canvas.width;
            newLayer.canvas.height = canvas.height;
            newLayer.ctx = newLayer.canvas.getContext('2d');

            layers.push(newLayer);
            setActiveLayer(layers.length - 1);  // make new layer active
            updateLayerMenu();
        }



        // Function to update the layer menu dynamically
        function updateLayerMenu() {
            const layerContent = document.getElementById("layerContent");
            layerContent.innerHTML = ''; // Clear previous layers

            // ðŸ” Loop in REVERSE so newest layers appear first (on top)
            [...layers].reverse().forEach((layer, visualIndex) => {
                const actualIndex = layers.length - 1 - visualIndex;

                const layerDiv = document.createElement('div');
                layerDiv.classList.add('layer-item');
                if (actualIndex === activeLayerIndex) {
                    layerDiv.classList.add('selected');
                }

                // ðŸ§± Grid layout
                layerDiv.style.display = 'grid';
                layerDiv.style.gridTemplateColumns = 'auto auto auto';
                layerDiv.style.alignItems = 'center';
                layerDiv.style.columnGap = '6px';
                layerDiv.style.marginBottom = '6px';

                // ðŸ–¼ Thumbnail
                const thumb = document.createElement('canvas');
                const thumbWidth = 32;
                const thumbHeight = 24;
                thumb.width = thumbHeight;
                thumb.height = thumbHeight;

                thumb.style.width = `${thumbWidth}px`;
                thumb.style.height = `${thumbHeight}px`;
                thumb.style.border = '1px solid #aaa';
                thumb.style.background = '#fff';
                thumb.style.imageRendering = 'pixelated';
                thumb.style.flexShrink = '0';

                const thumbCtx = thumb.getContext("2d");
                thumbCtx.imageSmoothingEnabled = false;
                thumbCtx.clearRect(0, 0, thumb.width, thumb.height);
                const preview = document.createElement('canvas');
                preview.width = thumb.width;
                preview.height = thumb.height;
                const previewCtx = preview.getContext('2d');
                previewCtx.imageSmoothingEnabled = true;
                previewCtx.drawImage(layer.canvas, 0, 0, preview.width, preview.height);

                // âœ… Visibility checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = layer.visible;
                checkbox.addEventListener('change', () => {
                    toggleLayerVisibility(actualIndex);
                    renderAllLayers();
                });

                // ðŸ“ Layer label (renameable)
                const labelWrapper = document.createElement('div');
                labelWrapper.classList.add('layer-label');
                labelWrapper.textContent = layer.name;
                labelWrapper.style.cursor = 'text';
                labelWrapper.style.flexGrow = '0';
                labelWrapper.style.width = 'fit-content';

                labelWrapper.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = layer.name;
                    input.style.width = '100%';
                    input.style.boxSizing = 'border-box';
                    input.style.fontSize = 'inherit';
                    input.style.border = '1px solid #ccc';
                    input.style.borderRadius = '4px';
                    input.style.padding = '2px 4px';


                    labelWrapper.replaceChildren(input);
                    input.focus();

                    function commitRename() {
                        const newName = input.value.trim();
                        if (newName) {
                            layer.name = newName;
                        }
                        updateLayerMenu();
                    }

                    input.addEventListener('blur', commitRename);
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') input.blur();
                        if (e.key === 'Escape') updateLayerMenu();
                    });
                });

                // ðŸ–±ï¸ Clicking anywhere on the row (except checkbox) sets it active
                layerDiv.addEventListener('click', (e) => {
                    if (e.target !== checkbox) {
                        setActiveLayer(actualIndex);
                    }
                });

                // âœ… Assemble UI
                layerDiv.appendChild(thumb);
                layerDiv.appendChild(checkbox);
                layerDiv.appendChild(labelWrapper);
                layerContent.appendChild(layerDiv);
            });

            updateLayerThumbnails();
        }




        function updateLayerThumbnails() {
            const thumbnails = document.querySelectorAll(".layer-item canvas");

            [...layers].reverse().forEach((layer, visualIndex) => {
                const thumb = thumbnails[visualIndex];
                const ctx = thumb.getContext("2d");
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, thumb.width, thumb.height);
                ctx.drawImage(layer.canvas, 0, 0, thumb.width, thumb.height);
            });
        }




        // Draw something on the background layer (optional)
        layers[0].ctx.fillStyle = "#FFFFFF";
        layers[0].ctx.fillRect(0, 0, layers[0].canvas.width, layers[0].canvas.height);

        
   




        let isDrawing = false;
        let mouseDown = false;
        let lastX = 0;
        let lastY = 0;
        let brushSize = 2;
        let brushColor = "#000000";
        let isEraser = false;
        let hasDrawn = false;
        let isEyedropper = false;
        let isBucket = false;
         // Default to drawing layer

        function fillCanvasWhite() {
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        function renderAllLayers() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ðŸ‘‡ Draw from bottom layer to top â€” assuming layer[0] is bottom
            for (let i = 0; i < layers.length; i++) {
                if (layers[i].visible) {
                    ctx.drawImage(layers[i].canvas, 0, 0);
                }
            }
        }






        function saveDrawingState() {
            const layer = layers[activeLayerIndex];
            const imgData = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);
            layer.undoStack.push(imgData);
            // Clear redo stack when new state is added
            layer.redoStack = [];
        }




        function startDrawing(x, y) {
            isDrawing = true;
            mouseDown = true;
            hasDrawn = false;
            [lastX, lastY] = [x, y];

            if (isEyedropper) {
                handleToolClick(Math.floor(x), Math.floor(y));
            } else if (isBucket) {
                const layer = layers[activeLayerIndex];
                const currentState = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);
                layer.undoStack.push(currentState);
                layer.redoStack = [];
                handleToolClick(Math.floor(x), Math.floor(y));
            } else {
                // For regular drawing/erasing, save state at the beginning
                const layer = layers[activeLayerIndex];
                const currentState = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);
                layer.undoStack.push(currentState);
                layer.redoStack = [];
            }
        }

        function draw(x, y) {
            if (isEyedropper || isBucket || !isDrawing) return;

            // Always mark something was drawn/erased
            hasDrawn = true;



            const layerCtx = layers[activeLayerIndex].ctx;  // Get context of the active layer
            layerCtx.beginPath();
            layerCtx.moveTo(lastX, lastY);
            layerCtx.lineTo(x, y);
            layerCtx.lineWidth = brushSize;
            layerCtx.lineCap = "round";

            if (isEraser) {
                if (activeLayerIndex === 0) {
                    // Background layer: draw white
                    layerCtx.globalCompositeOperation = "source-over";
                    layerCtx.strokeStyle = "#FFFFFF";
                } else {
                    // Other layers: erase to transparency
                    layerCtx.globalCompositeOperation = "destination-out";
                    layerCtx.strokeStyle = "rgba(0,0,0,1)"; // any solid color works here
                }
            } else {
                layerCtx.globalCompositeOperation = "source-over";
                layerCtx.strokeStyle = brushColor;
            }

            layerCtx.stroke();

            [lastX, lastY] = [x, y];

            renderAllLayers();  // Re-render layers after drawing
            updateLayerThumbnails();  // ðŸ’¡ Live update the thumbnails
        }


        function stopDrawing() {
            

            isDrawing = false;
            mouseDown = false;
        }


        function floodFill(x, y, targetHex, fillHex) {
            const fillRGB = hexToRgb(fillHex);
            const layerCtx = layers[activeLayerIndex].ctx;
            const imageData = layerCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            const visited = new Uint8Array(width * height);
            const queue = [[x, y]];

            const startIndex = (y * width + x) * 4;
            const targetRGB = [
                data[startIndex],
                data[startIndex + 1],
                data[startIndex + 2],
                data[startIndex + 3]
            ];

            // Skip only if the pixel matches EXACTLY the fill color including alpha
            if (
                targetRGB[0] === fillRGB[0] &&
                targetRGB[1] === fillRGB[1] &&
                targetRGB[2] === fillRGB[2] &&
                targetRGB[3] === 255
            ) return;

            function colorAt(x, y) {
                const i = (y * width + x) * 4;
                return [data[i], data[i + 1], data[i + 2], data[i + 3]];
            }

            function setColor(x, y) {
                const i = (y * width + x) * 4;
                data[i] = fillRGB[0];
                data[i + 1] = fillRGB[1];
                data[i + 2] = fillRGB[2];
                data[i + 3] = 255;
            }

            function matchColor(c1, c2) {
                // Allow some small tolerance (good for antialiasing cases)
                return (
                    Math.abs(c1[0] - c2[0]) < 5 &&
                    Math.abs(c1[1] - c2[1]) < 5 &&
                    Math.abs(c1[2] - c2[2]) < 5 &&
                    Math.abs(c1[3] - c2[3]) < 5
                );
            }

            while (queue.length > 0) {
                const [cx, cy] = queue.shift();
                if (cx < 0 || cy < 0 || cx >= width || cy >= height) continue;

                const idx = cy * width + cx;
                if (visited[idx]) continue;

                const current = colorAt(cx, cy);
                if (!matchColor(current, targetRGB)) continue;

                setColor(cx, cy);
                visited[idx] = 1;

                queue.push([cx + 1, cy]);
                queue.push([cx - 1, cy]);
                queue.push([cx, cy + 1]);
                queue.push([cx, cy - 1]);
            }

            layerCtx.putImageData(imageData, 0, 0);
            renderAllLayers();
            updateLayerThumbnails();  // âœ… Live update after filling
        }




        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b];
        }

        function rgbToHex(r, g, b) {
            return (
                "#" +
                [r, g, b]
                    .map((x) => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? "0" + hex : hex;
                    })
                    .join("")
                    .toUpperCase()
            );
        }

        function handleToolClick(x, y) {
            if (isEyedropper) {
                // Create a temporary canvas to composite visible layers
                const tempCanvas = document.createElement("canvas");
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext("2d");

                // Composite all visible layers from bottom to top
                for (let i = 0; i < layers.length; i++) {
                    if (layers[i].visible) {
                        tempCtx.drawImage(layers[i].canvas, 0, 0);
                    }
                }

                // Sample pixel from merged result
                const pixel = tempCtx.getImageData(x, y, 1, 1).data;
                const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);

                brushColor = hex;
                colorPicker.value = hex;
                updateLayerThumbnails();  // Optional
            }
            else if (isBucket) {
                // Bucket still uses the active layer only
                const layerCtx = layers[activeLayerIndex].ctx;
                const targetPixel = layerCtx.getImageData(x, y, 1, 1).data;
                const targetHex = rgbToHex(targetPixel[0], targetPixel[1], targetPixel[2]);
                floodFill(x, y, targetHex, brushColor); // âœ… This must stay
            }
        }



        canvas.addEventListener("touchstart", (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            const touchY = e.touches[0].clientY - rect.top;
            startDrawing(touchX, touchY);
        });

        canvas.addEventListener("touchmove", (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            const touchY = e.touches[0].clientY - rect.top;
            draw(touchX, touchY);
        });

        canvas.addEventListener("touchend", stopDrawing);
        canvas.addEventListener("mousedown", (e) => startDrawing(e.offsetX, e.offsetY));
        canvas.addEventListener("mousemove", (e) => draw(e.offsetX, e.offsetY));
        canvas.addEventListener("mouseup", stopDrawing);
        document.addEventListener("mouseup", stopDrawing);

        brushSizeInput.addEventListener("input", (e) => {
            brushSize = e.target.value;
            sizeLabel.textContent = brushSize;
        });

        colorPicker.addEventListener("input", (e) => {
            brushColor = e.target.value;
        });

        eraserIcon.addEventListener("click", () => {
            isEraser = true;
            isEyedropper = false;
            isBucket = false;
            highlightTool("eraser");
        });

        brushIcon.addEventListener("click", () => {
            isEraser = false;
            isEyedropper = false;
            isBucket = false;
            highlightTool("brush");
        });

        eyedropperIcon.addEventListener("click", () => {
            isEyedropper = true;
            isEraser = false;
            isBucket = false;
            highlightTool("eyedropper");
        });

        bucketIcon.addEventListener("click", () => {
            isBucket = true;
            isEraser = false;
            isEyedropper = false;
            highlightTool("bucket");
        });

        function highlightTool(tool) {
            brushIcon.style.border = tool === "brush" ? "2px solid black" : "none";
            eraserIcon.style.border = tool === "eraser" ? "2px solid black" : "none";
            eyedropperIcon.style.border = tool === "eyedropper" ? "2px solid black" : "none";
            bucketIcon.style.border = tool === "bucket" ? "2px solid black" : "none";
        }

        undoButton.addEventListener("click", () => {
            const layer = layers[activeLayerIndex];
            if (layer.undoStack.length > 0) {
                const currentState = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);
                layer.redoStack.push(currentState);

                const prevState = layer.undoStack.pop();
                layer.ctx.putImageData(prevState, 0, 0);
                renderAllLayers();
                updateLayerThumbnails();
            }
        });



        redoButton.addEventListener("click", () => {
            const layer = layers[activeLayerIndex];
            if (layer.redoStack.length > 0) {
                const currentState = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);
                layer.undoStack.push(currentState);

                const redoState = layer.redoStack.pop();
                layer.ctx.putImageData(redoState, 0, 0);
                renderAllLayers();
                updateLayerThumbnails();
            }
        });



        submitButton.addEventListener("click", () => {
            const imageData = canvas.toDataURL("image/png");

            fetch(imageData)
                .then(res => res.blob())
                .then(blob => {
                    const formData = new FormData();
                    formData.append("file", blob, "doodle.png");

                    fetch("https://discord.com/api/webhooks/1359909431868915953/WrhoQ4ZpZU0JG-Fvh197BuekJdXC56OYJbBHclhYiuvGqu0fhoKJ-6bjb3nwRoqxw7NM", {
                        method: "POST",
                        body: formData
                    })
                        .then(response => {
                            if (response.ok) {
                                alert("Submitted!");
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                fillCanvasWhite();
                                saveDrawingState();
                            } else {
                                alert("Submission failed.");
                                console.error("Error:", response.statusText);
                            }
                        })
                        
                        .catch(error => {
                            alert("Submission failed.");
                            console.error("Fetch error:", error);
                        });
                });
        });

        window.onload = () => {
            fillCanvasWhite();
            saveDrawingState();
            renderAllLayers();
        };
        document.addEventListener("keydown", (e) => {
            if (e.ctrlKey && !e.shiftKey && e.key === "z") {
                e.preventDefault();
                undoButton.click();
            } else if (e.ctrlKey && e.shiftKey && e.key === "Z") {
                e.preventDefault();
                redoButton.click();
            }
        });
        toggleLayerMenu.addEventListener("click", () => {
            const isVisible = layerMenu.style.display === "block";
            layerMenu.style.display = isVisible ? "none" : "block";
        });


    </script>
</body>
</html>